stage.stageHeight = 1136;stage.stageWidth = 640;stage.align = StageAlign.TOP_LEFT;stage.scaleMode = StageScaleMode.EXACT_FIT;root.transform.perspectiveProjection.projectionCenter = new Point( 320, 550);root.transform.perspectiveProjection.fieldOfView = 100;stop();//import Global;Multitouch.inputMode = MultitouchInputMode.TOUCH_POINT;addEventListener(TouchEvent.TOUCH_BEGIN, onTouchBegin);addEventListener(TouchEvent.TOUCH_MOVE, onTouchMove);addEventListener(TouchEvent.TOUCH_END, onTouchEnd);if (Multitouch.supportsTouchEvents == false) {	addEventListener(MouseEvent.MOUSE_DOWN, onTouchBegin);	addEventListener(MouseEvent.MOUSE_UP, onTouchEnd);	addEventListener(MouseEvent.MOUSE_MOVE, onTouchMove);}addEventListener(Event.ENTER_FRAME, onFrame); //every framevar prevX:Number;var prevY:Number;var curX:Number;var curY:Number;var ghostx:Number;var ghosty:Number;var Xspeed:Number =0;var Yspeed:Number =0;var screenw:Number = view.width;var screenh:Number = view.height;var dir:Number = 0;var speed:Number = 0;var friction:Number = 0.9;const snapspeed:Number = 0.55;var mousedown:Boolean = false;var returnx:Number;var returny:Number;var colliding:Boolean = false;const touchprecision:Number = 5;var speedmultiplier = 1.6;var speedmultipliertreshold = 80;var sm;var touchmoveID=0;Global.vars.art = art1;//the moving artwork, the mapvar lastfreex:Number = 0;var lastfreey:Number = 0;var tl:Boolean, tr:Boolean, bl:Boolean, br:Boolean, hor:Number, ver:Number, horOk:Boolean, verOk:Boolean;const limit:Number = 500;//limit on how far to check for touch collisionsconst draglimit = 400;//how far dragdummy can be from the current position of view//some type casted variables for frequent functions to speed thing upvar pfindex:DisplayObject;var nfi:Number; // for loop i in nearestfree and touchvar originalx:Number;var originaly:Number;var heropreviousx = 0;var heropreviousy = 0;var obstacles:Array = new Array();updateObstacles();function updateObstacles():void {	//find all obstacles	obstacles.length = 0;//clear the array for reuse	var len:int = this.numChildren;  	//trace("numchildren: " + len);	for (var i:int = 0; i < len; i++) {  //go through all children of the scene	    var child = this.getChildAt(i);  		//trace(child);	    if (child is greenbox) {//if this child is a greenbox			obstacles.push(child);//push it to the end of the array of obstacles		};		if (child is obstaclecontainer) {		var len2:int = child.numChildren;			for (var j:int = 0; j < len2; j++) {  //go through all children	    		var child2:DisplayObject = child.getChildAt(j);  					//trace(child);	    		if (child2 is greenbox) {//if this child is a greenbox					obstacles.push(child2);//push it to the end of the array of obstacles				};			};		};	};};trace(obstacles);//touch events:function onTouchBegin(eBegin):void {	//if (touchmoveID == 0) { //no previous move touch going on    	//touchmoveID = eBegin.touchPointID;		dragdummy.startDrag(false, null);    	 //trace("touch begin"); 		prevX = eBegin.stageX;		prevY = eBegin.stageY;		curX = eBegin.stageX;		curY = eBegin.stageY;		mousedown = true;	//} }function onTouchMove(eMove):void {	if (mousedown /*&& eMove.touchPointID == touchmoveID*/) {    //trace(eMove.stageX);	prevX = curX;	prevY = curY;	curX = eMove.stageX;	curY = eMove.stageY;	}} function onTouchEnd(eEnd):void {	//if (eEnd.touchPointID == touchmoveID) {//only respond to the moving touch     dragdummy.stopDrag();     //trace("touch end");	 //trace(curX - prevX, curY - prevY);	 Xspeed = Math.max(-100,Math.min(100,curX-prevX));//limit speed	 Yspeed = Math.max(-80,Math.min(80,curY-prevY));	 dragdummy.x = Math.max(-view.x-draglimit,Math.min(-view.x + draglimit, dragdummy.x)); // dont let the dragdummy go too far, we might be stuck	 dragdummy.y = Math.max(-view.y-draglimit,Math.min(-view.y + draglimit, dragdummy.y));	 if (Math.abs(Xspeed) + Math.abs(Yspeed) > speedmultipliertreshold) {//dont for very small movements		 Xspeed *= speedmultiplier;// * 1.5; //speed up, especially X, because drag width is shorter		 Yspeed *= speedmultiplier;	 }	 trace(Yspeed, Xspeed);	 mousedown = false;	 /*for each (var index in obstacles) {//for each obstacle		if (index.hitTestObject(view)) {			trace("hit!",index);			trace(closestescape(index));		}	 }*/	 touchmoveID = 0;//free up the moving touch	//}}function onFrame(e):void {//every frame	//updateObstacles();	if (!mousedown) {		dragdummy.x += Xspeed;		dragdummy.y += Yspeed;		applyfriction(friction);				art1.x = dragdummy.x;		art1.y = dragdummy.y;	}	tryToMoveScene();	if (colliding && !mousedown){		//bounce the dragdummy closer to the scene		dragdummy.x -= (view.x + dragdummy.x) * snapspeed;		dragdummy.y -= (view.y + dragdummy.y) * snapspeed;		if (Math.abs(dragdummy.x + view.x) < 1) dragdummy.x = -view.x; //if only 1 pixel difference, just go there		if (Math.abs(dragdummy.y + view.y) < 1) dragdummy.y = -view.y;		dragdummy.x = Math.max(-view.x-draglimit,Math.min(-view.x + draglimit, dragdummy.x)); // dont let the dragdummy go too far, we might be stuck		dragdummy.y = Math.max(-view.y-draglimit,Math.min(-view.y + draglimit, dragdummy.y));		//ease art closer to scene			}	if (colliding && mousedown){		Xspeed = 0; Yspeed = 0;	}	art1.x = dragdummy.x;	art1.y = dragdummy.y;	art1.x -= (art1.x + view.x) * 0.5;	art1.y -= (art1.y + view.y) * 0.5;	//trace(PointFree(0,0));	hero1.x = (((heropreviousx+art1.x)/2 + 250) + hero1.x*3) /4;	hero1.y = (((heropreviousy+art1.y)/2 +500) + hero1.y*3)/4;	heropreviousx = view.x;	heropreviousy = view.y}function tryToMoveScene():void {	if (isFree(-dragdummy.x, -dragdummy.y)) {		view.x = lastfreex = -dragdummy.x;		view.y = lastfreey = -dragdummy.y;		colliding = false;	}	else {		colliding = true;		//see which corner is colliding		tl = !PointFree(-dragdummy.x, -dragdummy.y);		tr = !PointFree(-dragdummy.x + view.width, -dragdummy.y);		bl = !PointFree(-dragdummy.x,-dragdummy.y + view.height);		br = !PointFree(-dragdummy.x + view.width, -dragdummy.y + view.height);		switch (Number(tl) + Number(tr) + Number(br) + Number(bl)) {//how many corners collide			case 1: case 0: {				trace("collided with one corner");				//here we should try to move to freedom				if (tl) {					hor = nearestHorizontalFree(-dragdummy.x, -dragdummy.x + limit, -dragdummy.y);					ver = nearestVerticalFree(-dragdummy.y, -dragdummy.y + limit, -dragdummy.x);					if ((isNaN(hor)) && (isNaN(ver))) {break;}//not found					if (hor +dragdummy.x < ver +dragdummy.y) {						view.x = hor;						//ver = nearestVerticalFree(-dragdummy.y, -dragdummy.y + limit, hor);						//if (ver != NaN) view.y = ver;						//Xspeed = 0;					}					else					{						view.y = ver;						//hor = nearestVerticalFree(-dragdummy.x, -dragdummy.x + limit, ver);						//if (hor != NaN) view.x = hor;						//Yspeed = 0;					}					break;				}				if (tr) {					hor = nearestHorizontalFree(-dragdummy.x, -dragdummy.x - limit, -dragdummy.y);					ver = nearestVerticalFree(-dragdummy.y, -dragdummy.y + limit, -dragdummy.x);					if ((isNaN(hor)) && (isNaN(ver))) {break;}//both hor and ver return a not found (10000 or -10000)					if (-(hor + dragdummy.x) < (ver +dragdummy.y)) {//if either one or both of hor and ver is found, go to the closer one						view.x = hor;						//ver = nearestVerticalFree(-dragdummy.y, -dragdummy.y + limit, hor);						//if (ver != -10000) view.y = ver;						//Xspeed = 0;					}					else					{						view.y = ver;						//hor = nearestVerticalFree(-dragdummy.x, -dragdummy.x - limit, ver);						//if (hor != -10000) view.x = hor;						//Yspeed = 0;					}					break;				}				if (bl) {					hor = nearestHorizontalFree(-dragdummy.x, -dragdummy.x + limit, -dragdummy.y);					ver = nearestVerticalFree(-dragdummy.y, -dragdummy.y - limit, -dragdummy.x);					if ((isNaN(hor)) && (isNaN(ver))) {break;}//not found					if ((hor +dragdummy.x) < -(ver +dragdummy.y)) {						view.x = hor;						//ver = nearestVerticalFree(-dragdummy.y, -dragdummy.y - limit, hor);						//if (ver != NaN) view.y = ver;						//Xspeed = 0;					}					else					{						view.y = ver;						//hor = nearestVerticalFree(-dragdummy.x, -dragdummy.x + limit, ver);						//if (hor != NaN) view.x = hor;						//Yspeed = 0;					}					break;				}				if (br) {					hor = nearestHorizontalFree(-dragdummy.x, -dragdummy.x - limit, -dragdummy.y);					ver = nearestVerticalFree(-dragdummy.y, -dragdummy.y - limit, -dragdummy.x);					if ((isNaN(hor)) && (isNaN(ver))) {break;}//not found					if (-(hor + dragdummy.x) < -(ver +dragdummy.y)) {						view.x = hor;						//ver = nearestVerticalFree(-dragdummy.y, -dragdummy.y - limit, hor);						//if (ver != -10000) view.y = ver;						//Xspeed = 0;					}					else					{						view.y = ver;						//hor = nearestVerticalFree(-dragdummy.x, -dragdummy.x - limit, ver);						//if (hor != -10000) view.x = hor;						//Yspeed = 0;					}					break;				}				break;			}			case 2: {//this is the easiest				trace("collided with two corner");												if ((tl && tr) || (bl && br)) {//if top or bottom					//Yspeed = 0;					touchVertically(view.y, -dragdummy.y);					if (!isFree(view.x, view.y)) {//if still failed, like sometimes does						trace("fail x!");						//we hit a corner awkwardly and need to move out up or down						hor = nearestVerticalFree(-dragdummy.y, -dragdummy.y - limit, -dragdummy.x);						ver = nearestVerticalFree(-dragdummy.y, -dragdummy.y + limit, -dragdummy.x);						if ((isNaN(hor)) && (isNaN(ver))) {break;}//not found						if (Math.abs(hor + dragdummy.y) < Math.abs(ver + dragdummy.y)) {							view.y = hor;						}						else						{							view.y= ver;						}					}									}				if ((tr && br) || (tl && bl)) {//if left or right					//Xspeed = 0;					touchHorizontally(view.x, -dragdummy.x);					if (!isFree(view.x, view.y)) {//if still failed, like sometimes does						trace("fail x!");						//we hit a corner awkwardly and need to move out sideways						hor = nearestHorizontalFree(-dragdummy.x, -dragdummy.x - limit, -dragdummy.y);						ver = nearestHorizontalFree(-dragdummy.x, -dragdummy.x + limit, -dragdummy.y);//reusing the ver variable as another hor in the positive direction						if ((isNaN(hor)) && (isNaN(ver))) {break;}//not found						if (Math.abs(hor +dragdummy.x) < Math.abs(ver+dragdummy.x)) {							view.x = hor;						}						else						{							view.x = ver;						}					}				}				break;			}			case 3: {//we are cornered				trace("collided with 3 corner");				//Yspeed = 0;				touchVertically(view.y, -dragdummy.y);				//Xspeed = 0;				touchHorizontally(view.x, -dragdummy.x);				break;			}			case 0: {//means we hit a spike on the side, probably				trace("case 0");				var px = view.x;				var py = view.y;				//view.x = lastfreex;				touchVertically(view.y, -dragdummy.y);				var pyy = view.y;				view.y = py;				//view.y = lastfreey;				touchHorizontally(view.x, -dragdummy.x);				if (Math.abs(view.x - px) > Math.abs(view.y - pyy)) {					view.x = px; //if moved y distance is smaller, go back to original				}				else				{					view.y = py;				}				break;			}			case 4: {				trace("Four motherfucking corners baby");				break;			}		}	}			//checks for collisions, if none in that direction, then moves the scene. 	horOk = isFree(-dragdummy.x, view.y);	verOk = isFree(view.x, -dragdummy.y);	if (horOk && verOk){		//collision free, lets go		view.x = -dragdummy.x;		view.y = -dragdummy.y;	}	else {	//otherwise....	//if only colliding on one axis		if (horOk && !verOk) {//if horizontal is ok			view.x = -dragdummy.x ;			//touchVertically(view.y, -dragdummy.y);			//Yspeed = 0;		}		if (verOk && !horOk) {//if vertical is ok			view.y = -dragdummy.y;			//touchHorizontally(view.x, -dragdummy.x);			//Xspeed = 0;		}	}	//touchVertically(view.y, -dragdummy.y);	//touchHorizontally(view.x, -dragdummy.x);	}function nearestHorizontalFree(x1, x2, yy):Number {	/*var plus = (x1<x2) ? touchprecision : -touchprecision;	for (nfi = x1; Math.abs(nfi-x2) > 0; nfi+=plus) {		if (isFree(nfi, yy)) {			return nfi;		}*/	if (x1<x2) 		{//small to large			for (nfi = x1; nfi <= x2; nfi += touchprecision)				{					if (isFree(nfi, yy)) { return nfi}				}			}		else			{//large to small			for (nfi = x1; nfi >= x2; nfi -= touchprecision)				{					if (isFree(nfi, yy)) { return nfi }				}		}			 			//plus *= 1.01; // increase plus	return NaN;//(x1<x2) ? 10000 : -10000;//not found}function nearestVerticalFree(x1, x2, yy):Number {//actually y1, y2, xx	/*var plus = (x1<x2) ? touchprecision : -touchprecision;	for (nfi = x1; Math.abs(nfi-x2) > 0; nfi+=plus) {		if (isFree(yy, nfi)) {			return nfi;		}		//plus *= 1.01; // increase plus	}*/	if (x1<x2) 		{//small to large			for (nfi = x1; nfi <= x2; nfi += touchprecision)				{					if (isFree(yy, nfi)) { return nfi}				}			}		else			{//large to small			for (nfi = x1; nfi >= x2; nfi -= touchprecision)				{					if (isFree(yy, nfi)) { return nfi }				}		}	return NaN;//(x1<x2) ? 10000 : -10000;//not found}function touchHorizontally(x1, x2):void {	if (x1<x2) {//small to large		for (nfi = x1 + touchprecision; nfi <= x2; nfi += touchprecision) {			if (!isFree(nfi, view.y)) {				view.x = nfi - touchprecision;				break;			}			//if didnt find collision:			if (isFree(x2, view.y)){				view.x = x2;			}			else			{				view.x = x2 - touchprecision;			}		}	}	else {		for (nfi = x1 - touchprecision; nfi >= x2; nfi -= touchprecision) {			if (!isFree(nfi, view.y)) {				view.x = nfi + touchprecision;				break;			}			//if didnt find collision:			if (isFree(x2, view.y)){				view.x = x2;			}			else			{				view.x = x2 + touchprecision;			}		}	}}function touchVertically(x1, x2):void {	if (x1<x2) {//small to large		for (nfi = x1 + touchprecision; nfi <= x2; nfi += touchprecision) {			if (!isFree(view.x, nfi)) {				view.y = nfi - touchprecision;				break;			}			//if didnt find collision:			if (isFree(view.x, x2)){				view.y = x2;			}			else			{				view.y = x2 - touchprecision;			}		}	}	else {		for (nfi = x1 - touchprecision; nfi >= x2; nfi -= touchprecision) {			if (!isFree(view.x, nfi)) {				view.y = nfi + touchprecision;				break;			}			//if didnt find collision:			if (isFree(view.x, x2)) {				view.y = x2;}				else{					view.y = x2 + touchprecision;				}		}	}	}function moveToFreedom(xx, yy, hh, vv):Boolean {//hh and vv is either 1 or -1 or 0	for (var i:Number = 0; i>300; i += touchprecision) {//iterate over the distance of screenh (longer than screenw) by precision pixels		if (isFree(xx + hh * i, yy + vv * i)) {			returnx = xx + hh * (i-touchprecision);			returny = yy + vv * (i-touchprecision);			return true;			break;		}	}	return false;//did not find freedom}function isFree(xx, yy):Boolean { //checks if no obstacles for view to be at (xx,yy)	/*if (!PointFree(xx, yy) ||	!PointFree(xx + view.width, yy) ||	!PointFree(xx,yy + view.height) ||	!PointFree(xx + view.width, yy + view.height))	{		return false;	}	else	{		return true;	}*/	originalx = view.x;//remember views position	originaly = view.y;	view.x =  xx;//temporarily put the view object here	view.y =  yy;	for each (pfindex in obstacles) {//for each obstacle		if (pfindex.hitTestObject(view)) {			view.x = originalx;// put the view back	 		view.y = originaly;			return false;//if even one hit is found, immediately return false		}	 }	 view.x = originalx;// put the view back	 view.y = originaly;	 return true;// if we got this far, there was no collision}function PointFree(xx, yy):Boolean { //checks if no obstacles at (xx,yy)	for each (pfindex in obstacles) {//for each obstacle		if (pfindex.hitTestPoint(xx,yy, true)) {			return false;//if even one hit is found, immediately return false		}	 }	 return true;// if we got this far, there was no collision}function applyfriction(fr):void {	Xspeed *= fr;	Yspeed *= fr;	if (Xspeed * Xspeed < 1 && Yspeed * Yspeed < 1) {		Xspeed = 0;		Yspeed = 0;	}}gotoAndStop("maze1");